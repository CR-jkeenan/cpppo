* cpppo -- Communication Protocol Python Parser and Originator

  Cpppo (pronounced 
  : 'c'+3*'p'+'o' 
  in Python) is used to implement binary
  communications protocol parsers.  The protocol's communication elements are
  described in terms of state machines which change state in response to input
  events, collecting the data and producing output data artifacts.

** Deterministic Finite Automata

   A cpppo.dfa will consume symbols from its source iterable, and yield
   (machine,state) transitions 'til a terminal state is reached.  If 'greedy',
   it will transition 'til we reach a terminal state and the next symbol does
   not product a transition.

   For example, if 'abbb,ab' is presented to the following machine with a
   no-input state E, and input processing states A and (terminal) B, it will
   accept 'ab' and terminate, unless greedy is specified in which case it will
   accept 'abbb' and terminate.

*** Basic State Machines

#   #+BEGIN_DITAA abplus.png -r -S
    #+BEGIN_EXAMPLE
        +-----+ 'a' +-----+ 'b' +-----+ 'b'
        |  E  |---->|  A  |---->| (B) |----+
        +-----+     +-----+     +-----+    |
                                   ^       |
                                   |       |
                                   +-------+
    #+END_EXAMPLE
#   #+END_DITAA
    
    This machine is easily created like this:
    
    #+BEGIN_SRC python
    # Basic DFA that accepts ab+
    E			= cpppo.state( "E" )
    A			= cpppo.state_input( "A" )
    B			= cpppo.state_input( "B", terminal=True )
    E['a']		= A
    A['b']		= B
    B['b']		= B

    BASIC		= cpppo.dfa( 'ab+', initial=E, context='basic' )
    #+END_SRC

*** Composite Machines

    A higher-level DFA can be produced by wrapping this one in a cpppo.dfa, and
    giving it some of its own transitions.  For example, lets make a machine that
    accepts 'ab+' separated by ',[ ]*'.
    
#   #+BEGIN_DITAA abplus_csv.png -r -S
    #+BEGIN_EXAMPLE
                           +------------------------------+    
                           |                              |
                           v                              |
        +----------------------------------------+        | None
        | (CSV)                                  |        |
        |  +-----+ 'a' +-----+ 'b' +-----+  'b'  | ',' +-----+ ' '
        |  |  E  |---->|  A  |---->| (B) |----+  |---->| SEP |----+
        |  +-----+     +-----+     +-----+    |  |     +-----+    |
        |                             ^       |  |        ^       |
        |                             |       |  |        |       |
        |                             +-------+  |        +-------+
        +----------------------------------------+
    #+END_EXAMPLE
#   #+END_DITAA
    
    This is implemented:
    
    #+BEGIN_SRC python
    # Composite state machine accepting ab+, ignoring ,[ ]* separators
    ABP			= cpppo.dfa( "ab+", initial=E )
    SEP			= cpppo.state_discard( "SEP" )
    ABP[',']		= SEP
    SEP[' ']		= SEP
    SEP[None]		= ABP

    CSV			= cpppo.dfa( 'CSV', initial=ABP, context='csv' )
    #+END_SRC
    
    When the lower level state machine doesn't recognize the input symbol for a
    transition, the higher level machine is given a chance to recognize them; in
    this case, a ',' followed by any number of spaces leads to a state_discard
    instance, which throws away the symbol.  Finally, it uses an "epsilon"
    (no-input) transition (indicated by a transition on None) to re-enter the
    main CSV machine to process subsequent symbols.
    
*** Machines from Regular Expressions

    We use [[https://github.com/ferno/greenery]] to convert regular expressions into
    greenery.fsm machines, and post-process these to produce a cpppo.dfa.  The
    regular expression '(ab+)((,[ ]*)(ab+))*' is equivalent to the above (except
    that it doesn't ignore the separators), and produces the following state
    machine:

#   #+BEGIN_DITAA abplus_regex.png -r -S
    #+BEGIN_EXAMPLE
                       +----------------------------+
                       |                            |
                       v                            | 'a' 
        +-----+ 'a' +-----+ 'b' +-----+ ',' +-----+ |
        |  0' |---->|  2  |---->| (3) |---->|  4  |-+
        +-----+     +-----+     +-----+     +-----+
                                  ^ |         ^ |    
                                  | | 'b'     | | ' '
                                  +-+         +-+    
    #+END_EXAMPLE
#   #+END_DITAA

    A regular expression based cpppo.dfa is created thus:

    #+BEGIN_SRC python
    # A regular expression; he default dfa name is the regular expression itself.
    REGEX		= cpppo.regex( initial='(ab+)((,[ ]*)(ab+))*', context='regex' )
    #+END_SRC

** Running State Machines

   State machines define the grammar for a language which can be run against a
   sentence of input.  All these machines ultimately use state_input instances
   to store their data; the path used is the cpppo.dfa's <context> + '_input':

   #+BEGIN_SRC python
    data		= cpppo.dotdict()
    for machine in [ BASIC, CSV, REGEX ]:
        path		= machine.context() + '_input' # default for state_input data
        source		= cpppo.peekable( str( 'abbbb, ab' ))
        with machine:
            for i,(m,s) in enumerate( machine.run( source=source, data=data )):
                print( "%s #%3d; next byte %3d: %-10.10r: %r" % (
                       m.name_centered(), i, source.sent, source.peek(), data.get(path) ))
        print( "Accepted: %r; remaining: %r\n" % ( data.get(path), ''.join( source )))
    print( "Final: %r" % ( data ))
    #+END_SRC
